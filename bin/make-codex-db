#!/usr/bin/env bun
// vi: ft=typescript


import * as fs          from 'node:fs/promises';
import { Dirent }       from 'node:fs';
import * as path        from 'node:path';
import * as os          from 'node:os';
import { SQL, sql }     from 'bun';
import { consola }      from 'consola';
import { TacitPromise } from 'taciturn';


/***************************************************************
  * types
  */

type Path = string;

interface Context {
  DEBUG: boolean;
  codexRoot?: string;
  codexDBPath?: string;
  db?: SQL;
  commentChars: Array<string>;
  blacklistedPaths: Array<string>;
}

interface FileObj extends Dirent {
  fullPath: Path;
  relPath: Path;
  subDir: Path;
  firstLine?: string;
  tags?: Array<string>;
  fileID?: number;
}

/***************************************************************
  * sqlite statements
  */

const createTablesSQL = `
  DROP TABLE IF EXISTS files;
  DROP TABLE IF EXISTS tags;
  CREATE TABLE files (
    fileID INTEGER PRIMARY KEY,
    relPath TEXT,
    subDir TEXT);
  CREATE TABLE tags (
    tag TEXT,
    fileID INTEGER REFERENCES files);
  CREATE INDEX IF NOT EXISTS idx_tags_tag ON tags(tag);
  CREATE INDEX IF NOT EXISTS idx_tags_fileID ON tags(fileID);`;



/***************************************************************/

const log = (message: string, fn=consola.info) => {
  return (arg: any) => {
    fn(message);
    return arg;
  }
};

// a function that takes an exit code and returns a closure that takes
// an Error, prints it, and exits with the exit code
const printErrorAndBailOut = (exitCode: number, customMessage?: string) => {
  return (error: Error) => {
    customMessage ? consola.error(customMessage) : consola.error(error.message);
    process.exit(exitCode);
  };
};

const fatalCantFindCodexRoot  = printErrorAndBailOut(1);
const fatalCantOpenDB         = printErrorAndBailOut(2);

const getCodexRoot = () => {
  const CODEX_ROOT = process.env["CODEX_ROOT"] ?? "";
  if (CODEX_ROOT === "") throw Error("Environment variable 'CODEX_ROOT' not defined");
  return CODEX_ROOT;
};

const updateBlacklistPaths = (pathRoot: Path, { blacklistedPaths }: Context): Array<Path> => {
  return blacklistedPaths.map(_ => path.join(pathRoot, _));
}

const pathExistsP = async (apath: Path): Promise<boolean> => {
  return fs.stat(apath)
    .then(() => true)
    .catch((err) => {
      if (err.code === 'ENOENT') return false;
      throw err;
    });
};

const removeOldDB = (apath: string) => fs.rm(apath);

const createDB = (fn: Path) => {
  try {
    return new SQL({ filename: fn, strict: true, adapter: 'sqlite' });
  } catch (error) {
    throw Error(`unable to open database: ${error}`);
  }
}

const turnOnForeignKeyConstraints = async (db: SQL) => {
  return db`PRAGMA foreign_keys = ON`.
    then(_ => db);
};

const createTables = (db: SQL) => { return db.unsafe(createTablesSQL) };

const getAllFilesRecursively = (root: string | undefined) => {
  if (!root) throw new Error("root is required");
  return fs.readdir(root, { withFileTypes: true, recursive: true });
};

const filesOnly = (i: Dirent) => i.isFile() && !i.name.match(/^\./);

const addAltPathsAsKey = (fileObj: Dirent, _: number, { codexRoot }: Context): FileObj => {
  const fullPath = path.join(fileObj.parentPath, fileObj.name);
  const relPath  = path.relative(codexRoot!, fullPath);
  const subDir   = relPath.split(path.sep)[0];
  return {
    ...fileObj,
    fullPath,
    relPath,
    subDir
  } as FileObj;
};

const notBlacklistedP = (i: FileObj, _: number, { blacklistedPaths }: Context) => {
  return !blacklistedPaths.some(bl => i.fullPath.includes(bl));
}

const addFirstLineAsKey = async (fileObj: FileObj): Promise<FileObj> => {
  return fs.readFile(fileObj.fullPath, 'utf-8').
    then(contents => contents.split(/\r?\n/)[0]).
    then(firstLine => {
      return {
        ...fileObj,
        firstLine
      } as FileObj;
    });
}

const addTags = (fileObj: FileObj, _: number, { commentChars }: Context) => {
  const removeComment = (astring: string) => {
    commentChars.forEach((cc) => {
      astring = astring.replace(new RegExp(`^\\s*${cc}\\s+`), "");
    });
    return astring;
  };

  if (!fileObj.firstLine) throw new Error("field `firstLine` is missing");
  const tags = [fileObj.subDir, ...removeComment(fileObj.firstLine).split(/\s*,\s*/)];
  return {
    ...fileObj,
    tags: [...new Set(tags)]
  };
};

const addAFileID = (fileObj: FileObj, i: number) => {
  return {
    ...fileObj,
    fileID: i
  };
};

const insertFiles = async (filesObj: Array<FileObj>, { db }: Context) => {
  if (!db) throw new Error("`db` isn't defined");
  const pods = filesObj.map(({ fileID, relPath, subDir }) => { return { fileID, relPath, subDir }; });
  return db`INSERT INTO files ${sql(pods, 'fileID', 'relPath', 'subDir')}`.
    then((_: any) => filesObj);
};

const insertTags = async (filesObj: Array<FileObj>, { db }: Context) => {
  const tagsObj = filesObj.map(({ tags, fileID }) => {
    if (!tags) throw new Error("tags is undefined");
    return tags.map(tag => { return { tag, fileID } });
  }).flat();
  return db!`INSERT INTO tags ${sql(tagsObj)}`.
    then((_: any) => filesObj);
};

const closeDB = ({ db }: Context) => { db!.close(); }

/***************************************************************/

/* starting context */
const context: Context = {
  DEBUG: false,
  commentChars: [ "#", "//", ";", "--" ],
  blacklistedPaths: ["node_modules", "make-db.js", "package.json",
                     "make-codex-db.js", "package-lock.json", "codex.db",
                     "cdx.js", "codex.js", "TOC.md", "another.js",
                     "another.ts", "codex.ts", "make-codex-db.ts"]
};

/***************************************************************/

TacitPromise.create(context).
  then(log("making codex SQLite DB", consola.box)).

  then(getCodexRoot).
    catch(fatalCantFindCodexRoot).
    tap("codexRoot").

  then(updateBlacklistPaths).
    tap("blacklistedPaths").

  focus('codexRoot').
    then(root => `${root}/codex.db`).
    tap("codexDBPath").

  when(pathExistsP, removeOldDB).

  then(log("creating sqlite db")).
    then(createDB).
    catch(fatalCantOpenDB).
    tap('db').
    then(turnOnForeignKeyConstraints).
    then(createTables).

  focus('codexRoot').
    then(getAllFilesRecursively).
    filter(filesOnly).
    map(addAltPathsAsKey).
    filter(notBlacklistedP).

  then(log("parsing tags")).
    map(addFirstLineAsKey, { concurrency: 10 }).
    map(addTags).
    map(addAFileID).

  then(log("inserting tags and files")).
    then(insertFiles).
    then(insertTags).

  finally(closeDB).
  
  catch(consola.error).
  then(log("done", consola.success));

